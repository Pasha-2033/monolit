Ошибки:
E00: неопределенная операция
E01: неопределенный регистр
E02: неопределенный вектор
E03: суперскалярное использование скалярной операций

Определение команд:
instruction arg0:r, arg1:r, arg2:r=arg0	//для r = a <operation> b, хардкодед: операнда 2 с контролем результата
instruction arg0:r, arg1:r				//для a = a <operation> b, хардкодед: операнда 2 без контроля результата
custom_instruction [[token:]arg [,...]]	//для опеределения своих команд, может быть как объединение инструкций (в том числе в пределах разных тактов), так и самостоятельное машинное слово
Реализация инструкции:
<instruction> = {
	opcode: <value>
	arg0: ...
	arg1: ...
	//для многоточия тоже сделать определение
}
Необходимая информация для компилятора:
compiler_definition = {
	word_size: <n bits>
	result_control: true/false
	AVR_num: <n>
}

Скалярное выполнение:
add r:0, r:1
xor r:2, r:3
shl r:4, r:5; shr r:6, r:7 //E03

Суперскалярное выполнение (c переопределением суперскалярности компилятором, запись 1, равнозначно записи 2 и 3):
_add r:0, r:1; _xor r:2, r:3
_shl r:4, r:5; _shr r:6, r:7

Суперскалярное выполнение (c переопределением суперскалярности компилятором, запись 2, равнозначно записи 1 и 3):
_add r:0, r:1; _xor r:2, r:3; _shl r:4, r:5; _shr r:6, r:7

Суперскалярное выполнение (c переопределением суперскалярности компилятором, запись 3, равнозначно записи 2 и 3):
_add r:0, r:1
_xor r:2, r:3
_shl r:4, r:5
_shr r:6, r:7

Суперскалярное выполнение (без переопределения суперскалярности компилятором, запись 1, равнозначно записи 2):
__add r:0, r:1; _xor r:2, r:3	//достаточно определить любую команду как блокирующую переопределение
_shl r:4, r:5					//несмотря на возможность суперскалярности с предыдущими инструкциями, оно не будет совмещено из-за блокировки
_shr r:6, r:7					//несмотря на возможность суперскалярности выражение _shl r:4, r:5; _shr r:6, r:7 не будет совмещено с __add r:0, r:1; _xor r:2, r:3 из-за блокировки

Суперскалярное выполнение (без переопределения суперскалярности компилятором, запись 2, равнозначно записи 1):
_add r:0, r:1; __xor r:2, r:3	//достаточно определить любую команду как блокирующую переопределение
_shl r:4, r:5					//несмотря на возможность суперскалярности с предыдущими инструкциями, оно не будет совмещено из-за блокировки
_shr r:6, r:7					//несмотря на возможность суперскалярности выражение _shl r:4, r:5; _shr r:6, r:7 не будет совмещено с _add r:0, r:1; __xor r:2, r:3 из-за блокировки

Пример скаляной многотактовой операции:
div r:1, r:2, r:3	//будет сформирован loop

Пример суперскалярной многотактовой операции (c переопределением суперскалярности компилятором):
_div r:0, r:1, r:2; _or r:3, r:4
_shr r:5, r:6 //будет вместе с _div и _or т.к. может быть записано как 2действия div; _or r:3, r:4; _shr r:5, r:6
//если мы запищем несколько суперскалярных одинаковых действий, мы можем их исполнить в нужном нам порядке, то есть:
_div r:0, r:1, r:2; _or r:3, r:4; _or r:5, r:6	//даст в первый такт суперскалярность первого or с первым тактом div, а во второй - второй or со вторым тактом div
//при этом компилятор может дополнять _div другими суперскалярным операциями без блокировки (запись ниже аналогична предыдущей)
_div r:0, r:1, r:2; _or r:3, r:4
_or r:5, r:6

Пример суперскалярной многотактовой операции (без переопределения суперскалярности компилятором):
__div r:0, r:1, r:2; _shr r:3, r:4
_or r:5, r:6; //shr бует суперскалярно с div, а or - нет

Векторное исполнение
vadd v:0, v:1, avr:<num>	//avr определяет размерность данных, то есть при 64х регистрах 1 - будет 64х, 2 - 128х и т.д.